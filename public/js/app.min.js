var items = {
    videoPrev       : null,
    this_video_prev : null,
    framePrev       : null,
    modalInfo       : null,
    videoCont       : null
}

var utils = {
    'width_window'        : 0,
    'height_window'       : 0,
    'left_dist'           : 0,
    'right_dist'          : 0,
    'incomplete_cover_dx' : false,
    'biggerMediafiles'    : null,
    'x'                   : null,
    'y'                   : null,
    'player'              : {
        'modal'     : null,
        'floating'  : null,
        'queue'     : null
    }
}

var html = {
    'prev_cover' : "<div class='prev_cover'></div>",
    'ombra_dx'   : "<div class='ombra_dx'></div>",
    'ombra_sx'   : "<div class='ombra_sx'></div>"
}

/**
 * Ritorna il baseurl del sito
 * 
 * @returns {String}
 */
function baseUrl() {
    var win_loc = window.location;
    if (win_loc.host === 'localhost') {
        return win_loc.protocol + "//" + win_loc.host + "/edutube/public/";
    }
    return win_loc.protocol + "//" + win_loc.host + "/remote/host/path/";
};

/**
 * Scrive in console solo se siamo su localhost
 * 
 * @param {String} msg
 * @returns {void}
 */
function debug_console(msg) {
    var win_loc = window.location;
    if (win_loc.host === 'localhost') {
        console.log(msg);
    }
}

/**
 * Scrive in console la risposta delle richieste via ajax
 * 
 * @param {type} xhr
 * @param {type} status
 * @param {type} error
 * @returns {undefined}
 */
function errorResponse(xhr, status, error) {
    debug_console(xhr);
    debug_console(status);
    debug_console(error);
}

/**
 * Ridimensiona e centra l'immagine contenuta in container passando le dimensione e il contenitore della stesa
 * 
 * @param {int} width_img
 * @param {int} height_img
 * @param {jQuery} container
 * @returns {Object}
 
function resizeImage(width_img, height_img, container) {
    
    var new_h_img_width_cont = (height_img/width_img)*container.width();
    console.log(container.height());
    
    var css = new Object();

    if (new_h_img_width_cont <= container.height()) {
        var width_num = ((width_img/height_img)*container.height());
        var height_num = container.height();
        css['width']       = width_num + 'px';
        css['height']      = height_num + 'px';
        css['margin-top']  = '0px';
        css['margin-left'] = (-(width_num-container.width())/2) + 'px';
    }
    else {
        css['width']       = container.width() + 'px';
        css['height']      = new_h_img_width_cont + 'px';
        css['margin-top']  = (-(new_h_img_width_cont - container.height())/2) + 'px';
        css['margin-left'] = '0px';
    }

    return css;
};*/

/**
 * Ritorna la distanza dal bordo top della finestra dell'elemento passato
 * 
 * @param {int} elem
 * @returns {int}
 */
function dist_from_top(elem) {
    var scrollTop     = $(window).scrollTop();
    var elementOffset = elem.offset().top;
    
    return (elementOffset - scrollTop);
}
/**
 * 
 * @param {type} this_video_prev
 * @param {type} ombra
 * @param {type} left_mod
 * @param {type} cover
 * @returns {undefined}
 */
function show_incomplete_prev(this_video_prev, ombra, left_mod, cover) {
    
    $(this_video_prev).css({'z-index': 200});
    $(this_video_prev).append(ombra);
    cover.append(html.prev_cover);

    $(this_video_prev).stop(true).animate({
        'left': left_mod
    }, 
    {
        duration : 100,
        start: function() {
            cover.find(".prev_cover").hide();

            $(this_video_prev).find($(ombra).attr("class")).hide();

            cover.find(".prev_cover").fadeTo(100, 0.5);
            $(this_video_prev).find($(ombra).attr("class")).fadeTo(100, 1);
        }
    });
}

/**
 * 
 * @param {type} this_video_prev
 * @param {type} ombra
 * @param {type} left_mod
 * @param {type} cover
 * @returns {undefined}
 */
function hide_incomplete_prev(this_video_prev, ombra, left_mod, cover) {
    
    $(this_video_prev).stop(true).animate({
        'left': left_mod
    }, 
    {
        duration : 100,
        start: function() {

            cover.find(".prev_cover").fadeTo(100, 0, function(){
                $(this).remove();
            });

            $(this_video_prev).find("."+$(ombra).attr("class")).fadeTo(100, 0, function() {
                $(this).remove();
            });
        },
        end: function() {
            $(this_video_prev).css({'z-index': 0});
        }
    });
}

/**
* 
* @param {type} event
* @returns {unresolved}
*/
function onPlayerStateChange(event, playerType) {

    if (utils.player['floating'] != null) {
        $('#floating_player').attr('ng-statuslistener', event.data);
    }
    
    if (utils.player['modal'] != null) {
        $('#myModal').attr('ng-statuslistener', event.data);
    }

    console.log('event.data' + event.data);

    switch (event.data) {
        case -1: return null; break;
        case 0 : 
            console.log('stop video');
            stopVideo(playerType); 

            /*if ($('#queue-box-cont').find('div').length > 0) {
                playerManageHelper($('#play-video-floating'), 'video-cont-floating', 'floating', 0);
            }*/

        break;
        case 2:
            console.log('pause video');
        break;
        case 5:
            console.log('cued video');
        break;
        default: return null; break;
    }

   /*var max_quality = event.target.getAvailableQualityLevels()[0];
   var current_quality = event.target.getPlaybackQuality();

   console.log(max_quality);
   console.log(current_quality);

   if (current_quality !== max_quality) {
       event.target.setPlaybackQuality(max_quality);
   }*/

}

/**
* 
* @param {type} event
* @returns {undefined}
*/
function onPlayerReady(event, start) {
    console.log('play');
    
    if (start>0) {
        event.target.seekTo(start, false);
    }
    
    event.target.playVideo();
}

/**
* 
* @param {type} cont
* @returns {Boolean}
*/
function stopVideo(playerType){
    
    if (utils.player[playerType] !== null) {

        utils.player[playerType].stopVideo();
        utils.player[playerType].clearVideo();
        utils.player[playerType].destroy();
        
        //utils.player[playerType] = null;
        
        return true;
    }
    return false;
}

/**
 * 
 * @param {type} playButton
 * @param {type} idVideoCont
 * @returns {undefined}
 */
function playerManageHelper(playButton, idVideoCont, playerType, start) {

    playButton.parent().append("<div id='" + idVideoCont + "' style='position: absolute; width:100%; height:100%; top:0px; padding-bottom:inherit'></div>");

    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";

    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var id = playButton.attr("data-videoid");

    utils.player[playerType] = new YT.Player(idVideoCont, {
        videoId: id,
        playerVars: {
            'showinfo': 0,
            'modestbranding': 0,
            'rel': 0
        },
        events: {
            'onReady': function(event) {
                onPlayerReady(event, start);
            },
            'onStateChange': function(event) {
                onPlayerStateChange(event, playerType);
            }
        }
    });/**/

}

/*function addVideoToQueue(queueBox) {
        var weight = $(queueBox).find('div').length;
            
        console.log($(queueBox).find('div').length);
            
        $('#play-video-floating').attr('data-videoid', $scope.item.YT_id);
        $('#play-video').attr('data-videoid', $scope.item.YT_id);

        $(queueBox).append('<div id="'+$scope.item.YT_id+'" data-status="-1" data-weight="' + weight + '"></div>');
    }
}*/

$(window).on('load', function(event){
});

$(window).on('resize', function(){
});

$(document).ready(function(){
        
    /**
     * 
     * @returns {undefined}
     */
    function dismissModal() {
        stopVideo('modal');
        $('div#video-cont').remove();
    }

    /**
     * 
     * @param {type} event
     * @returns {void}
     */
    function mousePosition(event) {
        utils.x = event.pageX;
        utils.y = event.pageY;
    }

    /**
     *  
     * @returns {void}
     */
    function playerManage() {
        playerManageHelper($(this), 'video-cont', 'modal', 0);
    }
    
    /**
     * 
     * @returns {void}
     */
    function playerManageFloating() {
        playerManageHelper($(this), 'video-cont-floating', 'floating', 0);
    }
    
    // LISTENERS
    
    $(document).on('hidden.bs.modal', '#myModal', dismissModal);
    //$(document).on('click', '#play-video', playerManage);
    //$(document).on('click', '#play-video-floating', playerManageFloating);
    $(document).on('mousemove mouseenter', mousePosition);
});
var app = angular.module('edutube', ['ngRoute', 'ngAnimate'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('{??');
    $interpolateProvider.endSymbol('??}');
});

app.constant('YT_event', {
    LOADING         : -2,
    UNSTARTED       : -1,
    ENDED           : 0,
    PLAYING         : 1,
    PAUSED          : 2,
    BUFFERING       : 3,
    VIDEO_CUED      : 5,
    
    STATUS_CHANGE   : 100,
    STOP            : 101, 
    PLAY            : 102,
    PAUSE           : 103
});

app.constant('MODAL_STATUS', {
    STATUS_CHANGE   : 200,
    CLOSE           : 201,
    OPEN            : 202
});

app.constant('QUEUE_event', {
    ADD : 300
})

/*app.run(function(){
    
});

app.config(function($routeProvider, $locationProvider) {
    $routeProvider.when('/',{
        templateUrl: 'angular/templates/viewPreview.template.html',
        controller: 'postWallController'
    });
});*/
/**
 * 
 * @param {type} param1
 * @param {type} param2
 */
app.filter('dateToISO', function() {
    return function(input) {
        if (input != undefined) {
            var goodTime = input.replace(/(.+) (.+)/, "$1T$2Z");
            return goodTime;
        }
        return null;
    };
});

/**
 * 
 */
app.filter('imgByName', function(){
    return function(input, name) {
        
        var imgUrl = '';
        
        if (input) {
            $.each(input, function(i, obj) {
                if (obj.nome === name) {
                    imgUrl = obj.url;
                    return false;
                }
            });

            if (imgUrl === '') {
                return 'placeholder';
            }
            return imgUrl;
        }
        return null
    };
});
/**
 * Permette di passare i dati tra la griglia e la modale e tra la modale e la floating.
 * Permette di getire una coda di post in attesa di gestione
 */
app.service('dataService', function ($http) {
    return {
        post: null,
        queue: [],
        current: 0,
        
        /**
         * 
         * @returns {Object}
         */
        getPosts: function () {
            var promise = $http
                .get(baseUrl() + 'api/posts')
                .then(function (resp) {
                    return resp.data.featured;
                });
            return promise;
        },
        
        /**
         * 
         * @param {Object} post
         * @returns {void}
         */
        setPost: function (post) {
            this.post = post;
        },
        /**
         * 
         * @returns {Object}
         */
        getPost: function () {
            return this.post;
        },
        
        /**
         * 
         * @returns {void}
         */
        iniPostQueue: function() {
            this.queue = [];
        },
        /**
         * 
         * @param {Object} item
         * @returns {void}
         */
        pushPostToQueue: function(item) {
            this.queue.push(item);
        },
        /**
         * 
         * @returns {Object}
         */
        popPostToQueue: function() {
            return this.queue.pop();
        },
        /**
         * 
         * @returns {int}
         */
        getQueueDim: function() {
            return this.queue.length;
        },
        /**
         * 
         * @param {int} index
         * @returns {Object}
         */
        getPostAtIndex: function(index) {
            this.current = index;
            return this.queue[index];
        },
        /**
         * 
         * @returns {Array}
         */
        getQueue: function() {
            return this.queue;
        },
        /**
         * 
         * @returns {int}
         */
        getCurrentIndex: function() {
            return this.current
        },
        /**
         * 
         * @returns {Object}
         */
        getCurrentPost: function() {
            return this.queue[this.current];
        },
        /**
         * 
         * @returns {Object}
         */
        getCurrentPostAndNext: function() {
            var post = this.queue[this.current];
            if ((this.current+1) < (this.getQueueDim()-1)) {
                this.current += 1;
            }
            return post;
        },
        /**
         * 
         * @returns {Object}
         */
        getCurrentPostAndPrev: function() {
            var post = this.queue[this.current];
            if ((this.current-1) > 0) {
                this.current -= 1;
            }
            return post;
        },
        /**
         * 
         * @returns {Object|Boolean}
         */
        nextPost: function() {
            if ((this.current+1) > (this.getQueueDim()-1)) {
                return false;
            }
            
            this.current += 1;
            return this.queue[this.current];
        },
        /**
         * 
         * @returns {Object|Boolean}
         */
        prevPost: function() {
            if ((this.current-1) < 0) {
                return false;
            }
            
            this.current -= 1;
            return this.queue[this.current];
        },
        /**
         * 
         */
        printStatus : function() {
            console.log("Queue: " + this.queue);
            console.log("Current: " + this.queue[this.current]);
            console.log("Current key: " + this.current);
        }
    };
});

/**
 * Da utilizzare per comunicare lo stato del player tra la modale la floating ed eventualmente altri controller.
 * In questo modo la floating può eventualmente partire da dove ha finito la modale
 */

app.service('playerStatus', function() {
    return {
        secFromStart : 0,
        playing      : false,
        paused       : false,
        stopped      : false,
        unstarted    : true,
        buffering    : false,
        loading      : false,
        
        /**
         * 
         * @returns {sec|Number}
         */
        getSecFromStart : function() {
            return this.secFromStart;
        },
        /**
         * 
         * @param {int} sec
         * @returns {void}
         */
        setSecFromStart : function(sec) {
            this.secFromStart = sec;
        },
        
        /**
         * 
         * @returns {play|Boolean}
         */
        isPlaying : function() {
            return this.playing;
        },
        /**
         * 
         * @param {boolean} play
         * @returns {void}
         */
        setPlay : function(play) {
            this.playing = play;
            if (this.playing) {
                this.paused = false;
                this.stopped = false;
                this.unstarted = false;
                this.buffering = false;
                this.loading = false;
            }
        },
        
        /**
         * 
         * @returns {Boolean|pause}
         */
        isPaused : function() {
            return this.paused;
        },
        /**
         * 
         * @param {boolean} pause
         * @returns {void}
         */
        setPause : function(pause) {
            this.paused = pause;
            if (this.paused) {
                this.playing = false;
                this.stopped = false;
                this.unstarted = false;
                this.buffering = false;
                this.loading = false;
            }
        },
        
        /**
         * 
         * @returns {stop|Boolean}
         */
        isStopped : function() {
            return this.stopped;
        },
        /**
         * 
         * @param {boolean} stop
         * @returns {void}
         */
        setStop : function(stop) {
            this.stopped = stop;
            if (this.stopped) {
                this.playing = false;
                this.paused = false;
                this.unstarted = false;
                this.buffering = false;
                this.loading = false;
            }
        },
        
        /**
         * 
         * @returns {unstart|Boolean}
         */
        isUnstarted : function() {
            return this.unstarted;
        },
        /**
         * 
         * @param {boolean} unstart
         * @returns {void}
         */
        setUnstart : function(unstart) {
            this.unstarted = unstart;
            if (this.unstarted) {
                this.secFromStart = 0;
                this.playing = false;
                this.paused = false;
                this.stopped = false;
                this.buffering = false;
                this.loading = false;
            }
        },
        
        /**
         * 
         * @returns {buffering|Boolean}
         */
        isBuffering : function() {
            return this.buffering;
        },
        /**
         * 
         * @param {boolean} buffering
         * @returns {void}
         */
        setBuffering : function(buffering) {
            this.buffering = buffering;
            if (this.buffering) {
                this.secFromStart = 0;
                this.loading = false;
                this.playing = false;
                this.paused = false;
                this.stopped = false;
                this.unstarted = false;
            }
        },
        
        /**
         * 
         * @returns {loaded|Boolean}
         */
        isLoading : function() {
            return this.loading;
        },
        /**
         * 
         * @param {boolean} load
         * @returns {void}
         */
        setLoading : function(load) {
            this.loading = load;
            if (this.loading) {
                this.secFromStart = 0;
                this.playing = false;
                this.paused = false;
                this.stopped = false;
                this.unstarted = false;
                this.buffering = false;
            }
        },
        
        /**
         * 
         */
        printStatus : function() {
            console.log("secFromStart: " + this.getSecFromStart());
            console.log("playing: " + this.isPlaying());
            console.log("paused: " + this.isPaused());
            console.log("stopped: " + this.isStopped());
            console.log("unstarted: " + this.isUnstarted());
            console.log("buffering: " + this.isBuffering());
            console.log("loading: " + this.isLoading());
        }
    }
})
/**
 * 
 * @param {type} param1
 * @param {type} param2
 */
app.controller('ItemsCtrl', function ItemsCtrl($scope, $rootScope, dataService, QUEUE_event) {
    
    /**
     * 
     * @returns {undefined}
     */
    $scope.update = function() {
        dataService.getPosts().then(function (data) {                       
            $scope.collection = data;
        });
    };
    
    $scope.update(); 
    
});

/**
 * Controller for main player modal window
 */
app.controller('modalInfoCtrl', function modalInfoCtrl($scope, $element, $rootScope, $window, dataService, playerStatus, YT_event, MODAL_STATUS){
    
    ////////////////////////////
    /////////// VARS ///////////
    ////////////////////////////
    
    $scope.YT_event = YT_event;
    $scope.yt = {
        playerStatus: YT_event.UNSTARTED
    }
    
    //////////////////////////////
    /////////// EVENTS ///////////
    //////////////////////////////
    
    /**
     * Listen for player status changes
     */
    $scope.$on(YT_event.STATUS_CHANGE, function (event, data, code) {
        switch (code) {
            case YT_event.LOADING:
                playerStatus.setLoading(true);
                break;
            case YT_event.UNSTARTED:
                playerStatus.setUnstart(true);
                break;
            case YT_event.PLAYING:
                playerStatus.setPlay(true);
                break;
            case YT_event.PAUSED:
                playerStatus.setPause(true);
                break;
            case YT_event.BUFFERING:
                playerStatus.setBuffering(true);
                break;
            case YT_event.ENDED:
                playerStatus.setStop(true);
                
                
                break;
        }
    });
    
    /**
     * Listen for the modal OPEN
     */
    $rootScope.$on(MODAL_STATUS.OPEN, function (status, data) {
        $element.fadeTo(200, 1).draggable();
        
        if (playerStatus.getSecFromStart()>0) {
            playerStatus.setPlay(true);
            $scope.$broadcast(YT_event.PLAY);
        }
    });
    
    ////////////////////////////////
    /////////// WATCHERS ///////////
    ////////////////////////////////
    
    /**
     * Init the modal data
     */
    $scope.$watch(function() {
            return dataService.post;
        }, 
        function(value, oldValue) {

            $scope.setModalGraphic()

        }, 
        true
    );
    
    ///////////////////////////////
    /////////// METHODS ///////////
    ///////////////////////////////
    
    /**
     * Play modal video
     * 
     * @returns {void}
     */
    $scope.playVideo = function() {
        playerStatus.setLoading(true);
        this.$broadcast(YT_event.PLAY);
    }
    
    /**
     * Stop modal video
     * 
     * @returns {void}
     */
    $scope.stopVideo = function() {
        
        if (playerStatus.isPlaying() || 
            playerStatus.isPaused() || 
            playerStatus.isBuffering() || 
            playerStatus.isLoading()) {
            
            this.$broadcast(YT_event.STOP);
        }
    }
    
    /**
     * Put item data into scope of the current modal
     *  
     * @returns {void}
     */
    $scope.setModalGraphic = function() {
        $scope.stopVideo();
        $scope.item = dataService.getPost();
    };
    
    /**
     * Show comment, related and description draggable and resizable boxes
     * 
     * @param {string} box
     * @returns {void}
     */
    $scope.showBox = function(box) {
        $(box).css({'z-index': 1000});
        $(box).fadeTo(100, 1);
        
        var widthModalDialog = $('.modal-dialog').width();
        
        $(box).draggable({
            containment: "parent",
            snap: "#myModal",
            stop: function(event, ui) {
                
            }
        });
        $(box).resizable({
            handles: "n, e, s, w, se",
            resize: function( event, ui ) {
                
            }
        });
    }
    
    /**
     * Hide comment, related and description draggable and resizable boxes
     * 
     * @param {string} box
     * @returns {void}
     */
    $scope.hideBox = function(box) {
        $(box).fadeTo(100, 0, function() {
            $(box).css({'z-index': -1000});
        });
    }
    
    /**
     * Give focus to the clicked box
     * 
     * @param {string} target       selector clicked box
     * @param {string} other_boxes  other opened boxes
     * @returns {void}
     */
    $scope.focus = function(target, other_boxes) {
        $(other_boxes).css({'z-index': 999});
        $(target).css({'z-index': 1000});
    }
    
    /**
     * Close the modal and open a floating box where a new player start playing
     * 
     * @param {string} box
     * @returns {void}
     */
    $scope.showFloating = function() {
       
        /*$scope.$watch(function() { return playerStatus }, function(value) {
            if (playerStatus.isPlaying() || playerStatus.isPaused() || playerStatus.isBuffering()) {
                this.$broadcast(YT_event.STOP);
            }
        })*/
        
        if (playerStatus.isPlaying() || 
            playerStatus.isPaused() || 
            playerStatus.isBuffering() || 
            playerStatus.isLoading()) {
        
            this.$broadcast(YT_event.STOP);
            
        }
        
        $rootScope.$emit(MODAL_STATUS.CLOSE, 'CLOSE');
        
    };

    /**
     * 
     * @param {String} queueBox
     * @returns {void}
     */
    $scope.addVideoToQueue = function() {
        dataService.pushPostToQueue($scope.item);
        $rootScope.$emit(QUEUE_event.ADD, 'ADD');
    }
    
});

/**
 * Controller for floating player window
 */
app.controller('pushpinCtrl', function pushpinCtrl($scope, $rootScope, $element, $window, dataService, playerStatus, YT_event, MODAL_STATUS, QUEUE_event){
    
    ////////////////////////////
    /////////// VARS ///////////
    ////////////////////////////
    
    $scope.YT_event = YT_event;
    $scope.yt = {
        playerStatus: YT_event.UNSTARTED
    }
    
    //////////////////////////////
    /////////// EVENTS ///////////
    //////////////////////////////
    
    /**
     * Listen for player status changes
     */
    $scope.$on(YT_event.STATUS_CHANGE, function (event, data, code) {
        switch (code) {
            case YT_event.LOADING:
                playerStatus.setLoading(true);
                break;
            case YT_event.UNSTARTED:
                playerStatus.setUnstart(true);
                break;
            case YT_event.PLAYING:
                playerStatus.setPlay(true);
                break;
            case YT_event.PAUSED:
                playerStatus.setPause(true);
                break;
            case YT_event.BUFFERING:
                playerStatus.setBuffering(true);
                break;
            case YT_event.ENDED:
                $scope.stopVideo();
                //playerStatus.setStop(true);
                
                /*
                if ($('#queue-box-cont').find('div').length > 0) {
                    $window.onYouTubeIframeAPIReady($scope.item.YT_id);
                }
                */
                                    
                if (dataService.getQueueDim() > 0) {
                    
                    $scope.item = dataService.getCurrentPostAndNext();
                    $scope.playVideo();
                    
                }
                break;
        }
    });
    
    /**
     * Listen for the modal status changes
     */
    $rootScope.$on(MODAL_STATUS.CLOSE, function (status, data) {
        $element.fadeTo(200, 1).draggable();
        
        if (playerStatus.getSecFromStart()>0) {
        //if (!playerStatus.isUnstarted()) {
            playerStatus.setPlay(true);
            $scope.$broadcast(YT_event.PLAY);
        }
    });
    
    ////////////////////////////////
    /////////// WATCHERS ///////////
    ////////////////////////////////
    
    $scope.$watch(function() {
            return dataService.post;
        }, 
        function(value, oldValue) {
            $scope.setFloatingGraphic();
            //playerStatus.setUnstart(true);
        }, 
        true
    );
    
    ///////////////////////////////
    /////////// METHODS ///////////
    ///////////////////////////////
    
    /**
     * Play modal video
     * 
     * @returns {void}
     */
    $scope.playVideo = function() {
        
        playerStatus.setLoading(true);
        this.$broadcast(YT_event.PLAY);

    }
    
    /**
     * Stop modal video
     * 
     * @returns {void}
     */
    $scope.stopVideo = function() {
        
        if (playerStatus.isPlaying() || 
            playerStatus.isPaused() || 
            playerStatus.isBuffering() || 
            playerStatus.isLoading()) {
            this.$broadcast(YT_event.STOP);
        }
    }
    
    /**
     * Put item data into scope of the current floating box
     * 
     * @returns {void}
     */
    $scope.setFloatingGraphic = function() {
        $scope.pushpinHide(); // altrimenti la floating non se ne va quando si apre un'altra modale 
        playerStatus.setUnstart(true);
        $scope.item = dataService.getPost();
    }; 
    
    /**
     * 
     * @param {type} floating_sel
     * @returns {undefined}
     */
    $scope.pushpinHide = function() {
        
        $scope.stopVideo();
        $element.fadeTo(200, 0);
        $element.css({
            'display': 'none'
        });
    };
    
    /**
     * 
     * @returns {undefined}
     */
    $scope.showModal = function() {
        $element.fadeTo(200, 0);
        
        if (playerStatus.isPlaying() || 
            playerStatus.isPaused() || 
            playerStatus.isBuffering() || 
            playerStatus.isLoading()) {
        
            this.$broadcast(YT_event.STOP);
        }
        
        $rootScope.$emit(MODAL_STATUS.OPEN, 'OPEN');
    }
    
    $scope.addVideoToQueue = function() {
        dataService.pushPostToQueue($scope.item);
        $rootScope.$emit(QUEUE_event.ADD, 'ADD');
    }
});

app.controller('QeueboxCtrl', function QeueBoxCtrl($scope, $document, $window, $element) {
    /**
     * init queue box
     */
    $document.ready(function () {
        
        $element.css({
            'bottom': -$element[0].offsetHeight + 'px'
        });
    });
    
    
    $scope.openCloseQueueBox = function() {
        
        if (($window.innerHeight - Math.ceil($element[0].getBoundingClientRect().top))>0) {
            $element.animate({
                'bottom': -$element[0].offsetHeight + 'px',
                //'-webkit-box-shadow': '0 0 0 0 rgba(0, 0, 0, 0.5)',
                //'box-shadow': '0 0 0 0 rgba(0, 0, 0, 0.5)'
            }, 100); 
        }
        else {
            $element.animate({
                'bottom': 0,
                //'-webkit-box-shadow': '0 0 100px 30px rgba(0, 0, 0, 0.5)',
                //'box-shadow': '0 0 100px 30px rgba(0, 0, 0, 0.5)'
            }, 100);
        }
    } 
});

app.controller('QeueCtrl', function QeueCtrl($scope, $rootScope, $element, dataService, playerStatus, QUEUE_event) {
    
    ////////////////////////////
    /////////// VARS ///////////
    ////////////////////////////
    
    //////////////////////////////
    /////////// EVENTS ///////////
    //////////////////////////////
    
    
    
    $rootScope.$on(QUEUE_event.ADD, function(data) {
        $scope.queue = dataService.getQueue();
    });
    
    ///////////////////////////////
    /////////// METHODS ///////////
    ///////////////////////////////
    
})

app.directive('isoRepeat', function ($timeout, $rootScope, dataService, playerStatus, QUEUE_event, YT_event) {
    return {
        scope: {
            items: '=isoRepeat'
        },
        templateUrl: 'angular/templates/viewPreview.template.html',
        link: function (scope, element, attrs) {

            var options = {
                itemSelector: '.video-prev',
                animationEngine : 'jquery',
                //percentPosition: true,
                masonry : {
                    columnWidth : '.video-prev',
                    isFitWidth: true,
                    gutter: 10
                }
            };

            element.isotope(options);

            scope.$watch('items', function(newVal, oldVal){
                $timeout(function(){
                    element.isotope( 'reloadItems' ).isotope({ sortBy: 'original-order' });
                }, true);
            });

            /**
             * TODO: Inizializza la modal, ma c'è troppo jquery, da rivedere
             * 
             * @param {type} item
             * @param {type} modal_sel
             * @returns {undefined}
             */
            scope.modalInfoShow = function(item, modal_sel){
            
                // INIT MODAL
                var modal = $(modal_sel);

                $('.modal-dialog').css({
                    //'margin': '0 auto',
                    'width': '100%'
                });
                $('.draggable-box').attr('style', '');

                $('.modal-dialog').draggable({
                    containment: "parent",
                    snap: "#myModal",
                    stop: function(event, ui) {
                    }
                });

                // TODO: ora che c'è la direttiva funcionante tutta questa parte può essere sbrigata dal template
                //var title            = item.title;
                var mediafiles       = item.mediafiles;
                var img_header       = modal.find('#img-prev-video');

                // si cerca l'ultimo file che dovrebbe essere il più grande possible
                // TODO: da verificare
                $.each(mediafiles, function(i, obj) {
                    utils.biggerMediafiles = obj;
                });
                
                item['src'] = utils.biggerMediafiles.url;
                dataService.setPost(item);

                var height = (modal.find('.img-video').width()/16)*9;
                var total_height = height + $('.video-info-modal ').outerHeight() + $('.dati-video').outerHeight() + $('.header').outerHeight() + 60;

                if (total_height > $(window).height()) {
                    height = height - (total_height-$(window).height());
                }

                modal.find('.img-video').css({
                    'height': '100%', 
                    'padding-bottom': $('.video-info-modal').outerHeight() + 'px'
                });

                $('.modal-dialog').resizable({
                    handles: "n, e, s, w, se",
                    resize: function( event, ui ) {
                        modal.find('.img-video').css({
                            'height': '100%', 
                            'padding-bottom': $('.video-info-modal').outerHeight() + 'px'
                        });
                    }
                });
                
            }

            scope.addVideoToQueue = function(item) {
                dataService.pushPostToQueue(item);
                $rootScope.$emit(QUEUE_event.ADD, 'ADD');/**/

                console.log(item.YT_id);
                
            }
        }
    }
});

app.directive('jnFitImg', function() {
    return {
        link: function(scope, element, attrs) {
            scope.resizeImage = function(width_img, height_img, container) {
    
                var new_h_img_width_cont = (height_img/width_img)*container.width();

                var css = new Object();

                if (new_h_img_width_cont <= container.height()) {
                    var width_num = ((width_img/height_img)*container.height());
                    var height_num = container.height();
                    css['width']       = width_num + 'px';
                    css['height']      = height_num + 'px';
                    css['margin-top']  = '0px';
                    css['margin-left'] = (-(width_num-container.width())/2) + 'px';
                }
                else {
                    css['width']       = container.width() + 'px';
                    css['height']      = new_h_img_width_cont + 'px';
                    css['margin-top']  = (-(new_h_img_width_cont - container.height())/2) + 'px';
                    css['margin-left'] = '0px';
                }
                
                console.log(css);

                return css;
            };
            
            scope.fitImg = function() {
                var imgContainer = $(element).parent();
                var img = $(element);
                
                console.log(imgContainer);
                console.log(img);
                
                var imgWidth = img.width();
                var imgHeight = img.height();
                
                console.log(imgWidth);
                console.log(imgHeight);
                
                imgContainer.css({'overflow':'hidden'})
                img.css(scope.resizeImage(imgWidth, imgHeight, imgContainer));
                
            }
            
            element.one('load', function() {
                scope.fitImg();
            })
            
        }
    }
})

/**
 * Based on poxrud/youtube-directive-example
 * Github https://github.com/poxrud/youtube-directive-example/blob/master/application.js
 * Blog post http://blog.oxrud.com/posts/creating-youtube-directive/
 */
app.directive('youtube', function($window, dataService, playerStatus, YT_event){
    
    return {
        restrict: "E",
        
        template: '<div style="width:100%; height:100%;"></div>',
        
        // NOTA: usare un isolated scope non permetteva di aggiornare correttamente lo scope, facendo console.log(scope) si aveva il valore corretto, facendo console.log(scope.videoid) si aveva il valore vecchio
        
        /*scope: {
            //videoid : '=videoid',
            //videoid : '@videoid'
        },*/

        link: function(scope, element, attrs) {
            
            var tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

            var player = null;
            
            scope.$on(YT_event.STOP, function () {
                
                attrs.$set('status',YT_event.ENDED);
                
                if ((!playerStatus.isLoading())&&
                    (!playerStatus.isUnstarted())) {
                /*if ((!playerStatus.isLoading())) {*/
                    
                    if (player !== null) {
                        playerStatus.setSecFromStart(player.getCurrentTime());
                
                        playerStatus.printStatus();
                
                        player.seekTo(0);
                        player.stopVideo();
                        player.clearVideo();
                        player.destroy();
                    }
                }
                
                element.css({
                    'width':'0', 
                    'height':'0', 
                    'padding-bottom':'inherit'
                });
                
                playerStatus.setStop(true);
                
            });
            
            /*console.log('0-scope');
            console.log(scope);
            console.log("scope.videoid: " + scope.videoid);*/

            scope.$on(YT_event.PLAY, function (event, args) {
                
                element.css({
                    'width':'100%', 
                    'height':'100%', 
                    'padding-bottom':'inherit'
                });
                
                /*console.log('1-scope');
                console.log(scope);
                console.log("scope.videoid: " + scope.videoid);*/

                $window.onYouTubeIframeAPIReady = function() {
                    
                    /*console.log('2-scope');
                    console.log(scope);
                    console.log("scope.videoid: " + scope.videoid);*/
                    
                    player = new YT.Player(element.children()[0], {
                        videoId: scope.item.YT_id,
                        //videoId: scope.videoid,
                        playerVars: {
                            'showinfo': 0,
                            'modestbranding': 0,
                            'rel': 0
                        },
                        events: {
                            'onReady': function(event) {
                                scope.$apply(function() {
                                    if (playerStatus.getSecFromStart()>0) {
                                        player.seekTo(playerStatus.getSecFromStart(), false);
                                    }
                                    player.playVideo();
                                    
                                });
                            },
                            'onStateChange': function(event) {
                                var message = {
                                    event: YT_event.STATUS_CHANGE,
                                    data: "",
                                    code: event.data
                                };
                                
                                attrs.$set('status', event.data);
                                
                                if (playerStatus.isStopped()) {
                                    player.seekTo(0);
                                    player.stopVideo();
                                    player.clearVideo();
                                    player.destroy();
                                    
                                    element.css({
                                        'width':'0', 
                                        'height':'0', 
                                        'padding-bottom':'inherit'
                                    });
                                }
                                else {
                                
                                    switch(event.data) {
                                        case YT.PlayerState.PLAYING:
                                            message.data = "PLAYING";
                                            break;
                                        case YT.PlayerState.ENDED:
                                            message.data = "ENDED";
                                            break;
                                        case YT.PlayerState.UNSTARTED:
                                            message.data = "NOT PLAYING";
                                            break;
                                        case YT.PlayerState.BUFFERING:
                                            message.data = "BUFFERING";
                                            break;
                                        case YT.PlayerState.PAUSED:
                                            message.data = "PAUSED";
                                            break;
                                    };

                                    scope.$apply(function() {
                                        scope.$emit(message.event, message.data, message.code);
                                    });
                                }
                            }
                        }
                    });
                };

                $window.onYouTubeIframeAPIReady();
                
                
            }); 

            scope.$on(YT_event.PAUSE, function () {
                player.pauseVideo();
                
                attrs.$set('status', YT_event.PAUSED);
                playerStatus.setPause(true);
            }); 
        }
    }
})

/**
 * 
 */
app.directive('jnHover', ['$animate', function($animate) {
    return function(scope, element, attrs) {

        element.hover(
            function() {
            
                element.find('.frame-prev').stop(true).animate({
                    'border-width' : '4px'
                },100);

                element.find('.video-instruments').stop(true).animate({
                    'top' : -$(this).find('.video-instruments').innerHeight() + 'px'
                },100);

                element.find('.cover-prev-img').fadeTo(100, 1);

            },
            function() {
                element.find('.frame-prev').stop(true).animate({
                    'border-width' : '0px'
                },100);

                element.find('.video-instruments').stop(true).animate({
                    'top' : '0px'
                },100);

                element.find('.cover-prev-img').fadeTo(100, 0);
                
                // se il menu è aperto, lasciando la preview si chiude
                element
                    .find('.video-instruments ')
                    .find(".dropdown-toggle[aria-expanded=true]")
                    .dropdown("toggle");
            }
        );
    }
}]);

/**
 * 
 */
app.directive('jnSlideHiddenElement', function() {
    return {
        link: function(scope, element, attrs) {
            element.hover(
                function() {
                    utils.left_dist       = element.offset().left;
                    utils.right_dist      = $(window).width() - (element.offset().left + element.width());

                    if (utils.left_dist<0) {

                        // elemento a sinistra parzialmente visibile

                        var ombra = html.ombra_dx;
                        var left_mod = "+=" + ((-utils.left_dist) + 10) + "px";
                        var cover = element.next();

                        show_incomplete_prev(element, ombra, left_mod, cover);
                    }
                    else if (utils.right_dist<0) {

                        // elemento a destra parzialmente visibile

                        var ombra = html.ombra_sx;
                        var left_mod = "-=" + ((-utils.right_dist) + 10)  + "px";
                        var cover = element.prev();

                        show_incomplete_prev(element, ombra, left_mod, cover);    
                    }/**/
                },
                function() {
                    if (utils.left_dist<0) {

                        var ombra = html.ombra_dx;
                        var left_mod = 0;
                        var cover = element.next();

                        hide_incomplete_prev(element, ombra, left_mod, cover);
                    }
                    else if (utils.right_dist<0) {

                        var ombra = html.ombra_sx;
                        var left_mod = element.prev().position().left + element.width() + 10 + "px";
                        var cover = element.prev();

                        hide_incomplete_prev(element, ombra, left_mod, cover);
                    }
                }
            );
        }
    }
});

/**
 * 
 */
app.directive('jnHoverFloating', ['$animate', function($animate) {
    return function(scope, element, attrs) {
        element.hover(
            function() {
                
                // appare titolo video floating
                var infoVideo = element.find('.video-info');
                infoVideo.stop(true).animate({
                   'bottom' : (-infoVideo.outerHeight()) + 'px' 
                },
                100);
                
                // appare header floating
                var header = element.find('.header');
                header.stop(true).animate({
                   'top' : (-header.outerHeight()) + 'px' 
                },
                100);
            },
            function() {
                
                // scompare titolo video floating
                var infoVideo = element.find('.video-info');
                infoVideo.stop(true).animate({
                   'bottom' : '0px' 
                },
                100);
                
                // scompare header floating
                var header = element.find('.header');
                header.stop(true).animate({
                   'top' : '0px' 
                },
                100);
            }
        );
    }
}]);

/**
 * 
 */

/*
app.directive('jnOnShowModal', function (dataService, playerStatus, $rootScope, YT_event, MODAL_STATUS) {
    
    return {
        link: function(scope, element, attrs) {
            
            scope.$watch(function() {
                    return dataService.post;
                }, 
                function(value, oldValue) {

                    scope.setModalGraphic()

                }, 
                true
            );
        }
    } 
});
*/

/**
 * 
 */
/*
app.directive('jnOnShowFloating', function(dataService, playerStatus) {
    return {
        link: function(scope, element, attrs) {
            
            scope.$watch(function() {
                    return dataService.post;
                }, 
                function(value, oldValue) {
                    scope.setFloatingGraphic();
                    playerStatus.setUnstart(true);
                }, 
                true
            );
    
        }
    } 
});
*/

/**
 * 
 */
app.directive('jnQueueSlide', function() {
    return {
        link: function(scope, element, attr) {
            scope.setWidth = function(element) {
                
                scope.width = 0;
                scope.lastLeft = 0;
                scope.direction = '';
                scope.lastOffset = 0;
                
                element.children().each(function(index, obj) {
                    scope.width = scope.width + $(obj).outerWidth();
                });
                
                $(element[0]).css({
                   'width': scope.width + 'px'
                });
                
                if (scope.width > $(window).width()) {
                    
                    // TODO: meglio se si usa lo scroll normale, nascondendo la scrollbar
                    
                    $(element).draggable({
                        axis: "x",
                        start: function(event, ui) {
                            //$(element).draggable( "enable" );
                        },
                        stop: function(event, ui) {
                            
                            
                            /*var newLeft = 0;
                            if (scope.direction === 'left') {
                                newLeft = scope.lastLeft - 100
                            }
                            else {
                                newLeft = scope.lastLeft + 100
                            }
                            $(element).stop().animate({
                                'left': newLeft + 'px'
                            }, 200);*/
                        },
                        drag: function(event, ui) {
                            
                            scope.lastOffset = ui.position.left - scope.lastLeft;
                            
                            console.log(scope.lastOffset);
                            
                            if (ui.position.left > scope.lastLeft) {
                                scope.direction = 'right';
                            }
                            else {
                                scope.direction = 'left';
                            }
                            
                            if (ui.position.left > 0) {
                                ui.position.left = 0;
                            }
                            
                            scope.lastLeft = ui.position.left;
                            
                        }
                    });
                }
                
                console.log(element[0].offsetWidth);
            }
        }
    }
}).directive('jnQueueSlideElement', function () {
    return {
        link: function(scope, element, attr) {
            scope.setWidth(element.parent());
        }
    }
});

//# sourceMappingURL=app.min.js.map